---
title: 小知识部分
date: '2018-05-11 10:00:00'
categories: [
前端两三事
]
layout: post
author: xy
---

### 一、数组排序问题

**冒泡排序**

重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。

```javascript
    //正序排序 第一种方式
    let array = [2,5,7,1,45,278,345,2,3,7,6]
    let temp;
    for(let i =0 ; i<=array.length ;i++){
        for(let j = i+1; j<array.length;j++){
            if(array[j]<array[i]){
                temp = array[i] 
                array[i] = array[j]
                array[j] = temp 
            }
        }
    }
    console.log('array=',array)
```

**sort排序**
```javascript
    //正序排序 第二种方式
    let array2 = [2,5,7,1,45,278,345,2,3,7,6]
    function sortFunc(a,b){
        return a-b
    }
    array2.sort(sortFunc)
    console.log('array2=',array2)
```


### 二、深拷贝和浅拷贝问题

**Object.assign()**
Object.assign()只能实现一维对象的深拷贝

```javascript
var obj1 = {x: 1, y: 2}, obj2 = Object.assign({}, obj1);
console.log(obj1) //{x: 1, y: 2}
console.log(obj2) //{x: 1, y: 2}
obj2.x = 2; //修改obj2.x
console.log(obj1) //{x: 1, y: 2}
console.log(obj2) //{x: 2, y: 2}
var obj1 = {
    x: 1, 
    y: {
        m: 1
    }
};
var obj2 = Object.assign({}, obj1);
console.log(obj1) //{x: 1, y: {m: 1}}
console.log(obj2) //{x: 1, y: {m: 1}}
obj2.y.m = 2; //修改obj2.y.m
console.log(obj1) //{x: 1, y: {m: 2}}
console.log(obj2) //{x: 2, y: {m: 2}}

```

**JSON.parse(JSON.stringfy(obj))**

```javascript
var obj1 = {
    x: 1, 
    y: {
        m: 1
    }
};
var obj2 = JSON.parse(JSON.stringify(obj1));
console.log(obj1) //{x: 1, y: {m: 1}}
console.log(obj2) //{x: 1, y: {m: 1}}
obj2.y.m = 2; //修改obj2.y.m
console.log(obj1) //{x: 1, y: {m: 1}}
console.log(obj2) //{x: 2, y: {m: 2}}
```
undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。

```javascript
var obj1 = {
    x: 1,
    y: undefined,
    z: function add(z1, z2) {
        return z1 + z2
    },
    a: Symbol("foo")
};
var obj2 = JSON.parse(JSON.stringify(obj1));
console.log(obj1) //{x: 1, y: undefined, z: ƒ, a: Symbol(foo)}
console.log(JSON.stringify(obj1)); //{"x":1}
console.log(obj2) //{x: 1}
```
发现，在将obj1进行JSON.stringify()序列化的过程中，y、z、a都被忽略了，也就验证了MDN文档的描述。既然这样，那JSON.parse(JSON.stringify(obj))的使用也是有局限性的，不能深拷贝含有undefined、function、symbol值的对象，不过JSON.parse(JSON.stringify(obj))简单粗暴，已经满足90%的使用场景了。






